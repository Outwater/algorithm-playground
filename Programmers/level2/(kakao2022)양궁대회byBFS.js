//* 난이도 및 풀이 시간
// start: 10:30
// end:
// 실제 난이도:  체감 난이도:
//* 문제이해
// 화살개수 n과 어피치가 쏜 점수배열 info 가 주어질 때, 라이언이 가장 큰 점수차로 이기기 위한 점수배열을 리턴(우승할 수 없는 경우 -1)

// 조건
// 1) 점수는 0 ~ 10점까지 존재
// 2) 점수계산
// 1. 어느누구도 못맞추면 k점 아무도 획득 x
// 2. k점을 같은 횟수로 맞추었다면 어피치가 +k점
// 3. 라이언이 어피치보다 더 많은 횟수를 맞추었다면 라이언 +k점
// 4. 최종점수로 우승자 선발, 단 최종점수 같다면 어피치가 우승자

// 3) 라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 여러 가지 일 경우,
// 가장 낮은 점수를 더 많이 맞힌 경우를 return 해주세요.
//  [2,3,1,0,0,0,0,1,3,0,0]과  선택 < [2,1,0,2,0,0,0,2,3,0,0] >
//* 1차시도 fail
// values를 기준으로 쏘기 시작할 경우 모든 케이스를 커버할 수 없다.
// ex) 10점의 value가 가장 높을 때, 10점을 쏘지 않는 케이스에서도 최적의 상황이 나올 수 있다.
//* 아이디어
// BFS를 통한 완전 탐색을 통해 해결시도
// 라이언이 쏠 수 있는 방법은, 어피치가 쏜 것보다 1발 많이 쏘거나, 어피치가 쏜 것은 아예 쏘지 않는 방법이다.

//* 풀이방법(순서도, 절차적프로그래밍)

//* 시간복잡도
// O()

//* 복습필요여부
//

function solution(n, info) {
  let maxDiff = 0;
  let rion_shoots = Array.from({ length: 11 }, () => 0);
  function dfs(sum_shoots_appeach, sum_shoots_lion, idx, shoot_cnt) {
    let diff = sum_shoots_appeach - sum_shoots_lion;
    if (shoot_cnt > n) return;

    if (idx === 10) {
      if (shoot_cnt < n) {
        rion_shoots[idx] = n - shoot_cnt;
      }
      return;
    }
  }

  dfs(0, 0, 0, 0, rion_shoots);
}

// console.log(solution(5, [2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0])); // [0,2,2,0,1,0,0,0,0,0,0]
// console.log(solution(1, [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])); // [-1]
// console.log(solution(9, [0, 0, 1, 2, 0, 1, 1, 1, 1, 1, 1])); // [1,1,2,0,1,2,2,0,0,0,0]
// console.log(solution(10, [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 3])); //	[1,1,1,1,1,1,1,1,0,0,2]
